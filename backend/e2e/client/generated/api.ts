/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * OpenAPI documentation for My API
 *
 * The version of the OpenAPI document: 59acdd34ea678de65cbe0a25f66df8cefdf5050b
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ConfigurationRes
 */
export interface ConfigurationRes {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationRes
     */
    'appVersion': string;
    /**
     * 
     * @type {number}
     * @memberof ConfigurationRes
     */
    'reloadIntervalMs': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigurationRes
     */
    'enabledDomains': Array<ConfigurationResEnabledDomainsEnum>;
}

export const ConfigurationResEnabledDomainsEnum = {
    Test: 'TEST'
} as const;

export type ConfigurationResEnabledDomainsEnum = typeof ConfigurationResEnabledDomainsEnum[keyof typeof ConfigurationResEnabledDomainsEnum];

/**
 * 
 * @export
 * @interface DecimalRange
 */
export interface DecimalRange {
    /**
     * 
     * @type {number}
     * @memberof DecimalRange
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof DecimalRange
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface LoginReq
 */
export interface LoginReq {
    /**
     * 
     * @type {string}
     * @memberof LoginReq
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginReq
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginRes
 */
export interface LoginRes {
    /**
     * 
     * @type {string}
     * @memberof LoginRes
     */
    'token': string;
    /**
     * 
     * @type {UserInfo}
     * @memberof LoginRes
     */
    'userInfo': UserInfo;
}
/**
 * 
 * @export
 * @interface PageDtoTestItemDto
 */
export interface PageDtoTestItemDto {
    /**
     * 
     * @type {Array<TestItemDto>}
     * @memberof PageDtoTestItemDto
     */
    'content': Array<TestItemDto>;
    /**
     * 
     * @type {PageMetadata}
     * @memberof PageDtoTestItemDto
     */
    'page': PageMetadata;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements': number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PageReq
 */
export interface PageReq {
    /**
     * 
     * @type {number}
     * @memberof PageReq
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageReq
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface RegisterReq
 */
export interface RegisterReq {
    /**
     * Is not valid Email
     * @type {string}
     * @memberof RegisterReq
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface RegisterUniqueEmailReq
 */
export interface RegisterUniqueEmailReq {
    /**
     * 
     * @type {string}
     * @memberof RegisterUniqueEmailReq
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RegisterUniqueEmailRes
 */
export interface RegisterUniqueEmailRes {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterUniqueEmailRes
     */
    'isUnique': boolean;
}
/**
 * 
 * @export
 * @interface StringDto
 */
export interface StringDto {
    /**
     * 
     * @type {string}
     * @memberof StringDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TemplateCreateReq
 */
export interface TemplateCreateReq {
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateReq
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateReq
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TemplateDetail
 */
export interface TemplateDetail {
    /**
     * 
     * @type {string}
     * @memberof TemplateDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDetail
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TemplateListRes
 */
export interface TemplateListRes {
    /**
     * 
     * @type {string}
     * @memberof TemplateListRes
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateListRes
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TemplateStepPosition = {
    First: 'FIRST',
    Middle: 'MIDDLE',
    Last: 'LAST'
} as const;

export type TemplateStepPosition = typeof TemplateStepPosition[keyof typeof TemplateStepPosition];


/**
 * 
 * @export
 * @enum {string}
 */

export const TemplateStepType = {
    Text: 'TEXT',
    Select: 'SELECT'
} as const;

export type TemplateStepType = typeof TemplateStepType[keyof typeof TemplateStepType];


/**
 * 
 * @export
 * @interface TestEntityDto
 */
export interface TestEntityDto {
    /**
     * 
     * @type {string}
     * @memberof TestEntityDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TestEntityDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestEntityDto
     */
    'category': TestEntityDtoCategoryEnum;
    /**
     * 
     * @type {TestEntityLogisticProp}
     * @memberof TestEntityDto
     */
    'logisticProp': TestEntityLogisticProp;
    /**
     * 
     * @type {boolean}
     * @memberof TestEntityDto
     */
    'available': boolean;
    /**
     * 
     * @type {Set<TestEntityProperty>}
     * @memberof TestEntityDto
     */
    'borrows': Set<TestEntityProperty>;
}

export const TestEntityDtoCategoryEnum = {
    Book: 'BOOK',
    Electronics: 'ELECTRONICS',
    Clothing: 'CLOTHING',
    Toy: 'TOY'
} as const;

export type TestEntityDtoCategoryEnum = typeof TestEntityDtoCategoryEnum[keyof typeof TestEntityDtoCategoryEnum];

/**
 * 
 * @export
 * @interface TestEntityLogisticProp
 */
export interface TestEntityLogisticProp {
    /**
     * 
     * @type {number}
     * @memberof TestEntityLogisticProp
     */
    'stockCount': number;
    /**
     * 
     * @type {number}
     * @memberof TestEntityLogisticProp
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface TestEntityProperty
 */
export interface TestEntityProperty {
    /**
     * Is not valid Email
     * @type {string}
     * @memberof TestEntityProperty
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TestEntityProperty
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface TestEntityRes
 */
export interface TestEntityRes {
    /**
     * 
     * @type {TestEntityDto}
     * @memberof TestEntityRes
     */
    'entity'?: TestEntityDto;
}
/**
 * 
 * @export
 * @interface TestItemDto
 */
export interface TestItemDto {
    /**
     * 
     * @type {string}
     * @memberof TestItemDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TestItemDto
     */
    'category': TestItemDtoCategoryEnum;
    /**
     * 
     * @type {number}
     * @memberof TestItemDto
     */
    'price': number;
}

export const TestItemDtoCategoryEnum = {
    Book: 'BOOK',
    Electronics: 'ELECTRONICS',
    Clothing: 'CLOTHING',
    Toy: 'TOY'
} as const;

export type TestItemDtoCategoryEnum = typeof TestItemDtoCategoryEnum[keyof typeof TestItemDtoCategoryEnum];

/**
 * 
 * @export
 * @interface TestItemListFilter
 */
export interface TestItemListFilter {
    /**
     * 
     * @type {string}
     * @memberof TestItemListFilter
     */
    'title'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestItemListFilter
     */
    'categories'?: Array<TestItemListFilterCategoriesEnum>;
    /**
     * 
     * @type {DecimalRange}
     * @memberof TestItemListFilter
     */
    'priceRange'?: DecimalRange;
}

export const TestItemListFilterCategoriesEnum = {
    Book: 'BOOK',
    Electronics: 'ELECTRONICS',
    Clothing: 'CLOTHING',
    Toy: 'TOY'
} as const;

export type TestItemListFilterCategoriesEnum = typeof TestItemListFilterCategoriesEnum[keyof typeof TestItemListFilterCategoriesEnum];

/**
 * 
 * @export
 * @interface TestRes
 */
export interface TestRes {
    /**
     * 
     * @type {string}
     * @memberof TestRes
     */
    'userFullName': string;
    /**
     * 
     * @type {boolean}
     * @memberof TestRes
     */
    'isAdmin': boolean;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'lastName'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof UserInfo
     */
    'role': UserRole;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserRole = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];


/**
 * 
 * @export
 * @interface WipStepConnectionCreateReq
 */
export interface WipStepConnectionCreateReq {
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionCreateReq
     */
    'sourceStepNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionCreateReq
     */
    'targetStepNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionCreateReq
     */
    'sourceOutput': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionCreateReq
     */
    'targetInput': string;
}
/**
 * 
 * @export
 * @interface WipStepConnectionData
 */
export interface WipStepConnectionData {
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionData
     */
    'sourceStepNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionData
     */
    'targetStepNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionData
     */
    'sourceOutput': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepConnectionData
     */
    'targetInput': string;
}
/**
 * 
 * @export
 * @interface WipStepCreateData
 */
export interface WipStepCreateData {
    /**
     * 
     * @type {string}
     * @memberof WipStepCreateData
     */
    'stepNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepCreateData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepCreateData
     */
    'question'?: string;
    /**
     * 
     * @type {TemplateStepPosition}
     * @memberof WipStepCreateData
     */
    'orderPosition': TemplateStepPosition;
    /**
     * 
     * @type {WipStepData}
     * @memberof WipStepCreateData
     */
    'data': WipStepData;
    /**
     * 
     * @type {Array<string>}
     * @memberof WipStepCreateData
     */
    'incomingConnections': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WipStepCreateData
     */
    'outgoingConnections': Array<string>;
    /**
     * 
     * @type {WipStepPosition}
     * @memberof WipStepCreateData
     */
    'gridPosition': WipStepPosition;
    /**
     * 
     * @type {WipStepNodeData}
     * @memberof WipStepCreateData
     */
    'nodeData': WipStepNodeData;
}


/**
 * 
 * @export
 * @interface WipStepData
 */
export interface WipStepData {
    /**
     * 
     * @type {TemplateStepType}
     * @memberof WipStepData
     */
    'type': TemplateStepType;
    /**
     * 
     * @type {WipStepTypeSelect}
     * @memberof WipStepData
     */
    'selectTypeData'?: WipStepTypeSelect;
}


/**
 * 
 * @export
 * @interface WipStepDetailRes
 */
export interface WipStepDetailRes {
    /**
     * 
     * @type {string}
     * @memberof WipStepDetailRes
     */
    'stepNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepDetailRes
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepDetailRes
     */
    'question'?: string;
    /**
     * 
     * @type {TemplateStepPosition}
     * @memberof WipStepDetailRes
     */
    'orderPosition': TemplateStepPosition;
    /**
     * 
     * @type {WipStepData}
     * @memberof WipStepDetailRes
     */
    'data': WipStepData;
    /**
     * 
     * @type {Array<string>}
     * @memberof WipStepDetailRes
     */
    'incomingConnections': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WipStepDetailRes
     */
    'outgoingConnections': Array<string>;
}


/**
 * 
 * @export
 * @interface WipStepListConnectionNode
 */
export interface WipStepListConnectionNode {
    /**
     * 
     * @type {string}
     * @memberof WipStepListConnectionNode
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepListConnectionNode
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface WipStepListRes
 */
export interface WipStepListRes {
    /**
     * 
     * @type {Array<WipStepListStep>}
     * @memberof WipStepListRes
     */
    'steps': Array<WipStepListStep>;
    /**
     * 
     * @type {Array<WipStepConnectionData>}
     * @memberof WipStepListRes
     */
    'connections': Array<WipStepConnectionData>;
}
/**
 * 
 * @export
 * @interface WipStepListStep
 */
export interface WipStepListStep {
    /**
     * 
     * @type {string}
     * @memberof WipStepListStep
     */
    'stepNumber': string;
    /**
     * 
     * @type {TemplateStepPosition}
     * @memberof WipStepListStep
     */
    'orderPosition': TemplateStepPosition;
    /**
     * 
     * @type {WipStepPosition}
     * @memberof WipStepListStep
     */
    'nodePosition': WipStepPosition;
    /**
     * 
     * @type {WipStepNodeData}
     * @memberof WipStepListStep
     */
    'nodeData': WipStepNodeData;
}


/**
 * 
 * @export
 * @interface WipStepNodeData
 */
export interface WipStepNodeData {
    /**
     * 
     * @type {string}
     * @memberof WipStepNodeData
     */
    'title': string;
    /**
     * 
     * @type {Array<WipStepListConnectionNode>}
     * @memberof WipStepNodeData
     */
    'inputs': Array<WipStepListConnectionNode>;
    /**
     * 
     * @type {Array<WipStepListConnectionNode>}
     * @memberof WipStepNodeData
     */
    'outputs': Array<WipStepListConnectionNode>;
}
/**
 * 
 * @export
 * @interface WipStepPosition
 */
export interface WipStepPosition {
    /**
     * 
     * @type {number}
     * @memberof WipStepPosition
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof WipStepPosition
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface WipStepTypeSelect
 */
export interface WipStepTypeSelect {
    /**
     * 
     * @type {Array<WipStepTypeSelectOption>}
     * @memberof WipStepTypeSelect
     */
    'options': Array<WipStepTypeSelectOption>;
}
/**
 * 
 * @export
 * @interface WipStepTypeSelectOption
 */
export interface WipStepTypeSelectOption {
    /**
     * 
     * @type {string}
     * @memberof WipStepTypeSelectOption
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof WipStepTypeSelectOption
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface WipStepUpdatePositionReq
 */
export interface WipStepUpdatePositionReq {
    /**
     * 
     * @type {WipStepPosition}
     * @memberof WipStepUpdatePositionReq
     */
    'position': WipStepPosition;
}
/**
 * 
 * @export
 * @interface WipStepUpdateReq
 */
export interface WipStepUpdateReq {
    /**
     * 
     * @type {string}
     * @memberof WipStepUpdateReq
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WipStepUpdateReq
     */
    'question'?: string;
    /**
     * 
     * @type {TemplateStepPosition}
     * @memberof WipStepUpdateReq
     */
    'orderPosition': TemplateStepPosition;
    /**
     * 
     * @type {WipStepData}
     * @memberof WipStepUpdateReq
     */
    'data': WipStepData;
}


/**
 * 
 * @export
 * @interface WipStepValidationRes
 */
export interface WipStepValidationRes {
    /**
     * 
     * @type {boolean}
     * @memberof WipStepValidationRes
     */
    'isValid': boolean;
    /**
     * 
     * @type {string}
     * @memberof WipStepValidationRes
     */
    'errorType'?: WipStepValidationResErrorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WipStepValidationRes
     */
    'errorMessage'?: string;
}

export const WipStepValidationResErrorTypeEnum = {
    MissingSteps: 'MISSING_STEPS',
    MissingRequiredFields: 'MISSING_REQUIRED_FIELDS',
    OnlyOneFirstStepRequired: 'ONLY_ONE_FIRST_STEP_REQUIRED',
    AtLeastOneLastStepRequired: 'AT_LEAST_ONE_LAST_STEP_REQUIRED',
    InvalidStepConnections: 'INVALID_STEP_CONNECTIONS'
} as const;

export type WipStepValidationResErrorTypeEnum = typeof WipStepValidationResErrorTypeEnum[keyof typeof WipStepValidationResErrorTypeEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isEmailUnique: async (registerUniqueEmailReq: RegisterUniqueEmailReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUniqueEmailReq' is not null or undefined
            assertParamExists('isEmailUnique', 'registerUniqueEmailReq', registerUniqueEmailReq)
            const localVarPath = `/api/auth/unique`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUniqueEmailReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginReq} loginReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginReq: LoginReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginReq' is not null or undefined
            assertParamExists('login', 'loginReq', loginReq)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterReq} registerReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerReq: RegisterReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerReq' is not null or undefined
            assertParamExists('register', 'registerReq', registerReq)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isEmailUnique(registerUniqueEmailReq: RegisterUniqueEmailReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUniqueEmailRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isEmailUnique(registerUniqueEmailReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.isEmailUnique']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginReq} loginReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginReq: LoginReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterReq} registerReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerReq: RegisterReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isEmailUnique(registerUniqueEmailReq: RegisterUniqueEmailReq, options?: any): AxiosPromise<RegisterUniqueEmailRes> {
            return localVarFp.isEmailUnique(registerUniqueEmailReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginReq} loginReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginReq: LoginReq, options?: any): AxiosPromise<LoginRes> {
            return localVarFp.login(loginReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterReq} registerReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerReq: RegisterReq, options?: any): AxiosPromise<void> {
            return localVarFp.register(registerReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public isEmailUnique(registerUniqueEmailReq: RegisterUniqueEmailReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).isEmailUnique(registerUniqueEmailReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginReq} loginReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginReq: LoginReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterReq} registerReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerReq: RegisterReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/public/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<ConfigurationRes> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getConfig(options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplateManagerApi - axios parameter creator
 * @export
 */
export const TemplateManagerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TemplateCreateReq} templateCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (templateCreateReq: TemplateCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateCreateReq' is not null or undefined
            assertParamExists('createTemplate', 'templateCreateReq', templateCreateReq)
            const localVarPath = `/api/p/template/manager/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplateById', 'id', id)
            const localVarPath = `/api/p/template/manager/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/p/template/manager/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateManagerApi - functional programming interface
 * @export
 */
export const TemplateManagerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateManagerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TemplateCreateReq} templateCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(templateCreateReq: TemplateCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(templateCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateManagerApi.createTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateManagerApi.getTemplateById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateListRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateManagerApi.listTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplateManagerApi - factory interface
 * @export
 */
export const TemplateManagerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateManagerApiFp(configuration)
    return {
        /**
         * 
         * @param {TemplateCreateReq} templateCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(templateCreateReq: TemplateCreateReq, options?: any): AxiosPromise<void> {
            return localVarFp.createTemplate(templateCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateById(id: string, options?: any): AxiosPromise<TemplateDetail> {
            return localVarFp.getTemplateById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(options?: any): AxiosPromise<Array<TemplateListRes>> {
            return localVarFp.listTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateManagerApi - object-oriented interface
 * @export
 * @class TemplateManagerApi
 * @extends {BaseAPI}
 */
export class TemplateManagerApi extends BaseAPI {
    /**
     * 
     * @param {TemplateCreateReq} templateCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateManagerApi
     */
    public createTemplate(templateCreateReq: TemplateCreateReq, options?: RawAxiosRequestConfig) {
        return TemplateManagerApiFp(this.configuration).createTemplate(templateCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateManagerApi
     */
    public getTemplateById(id: string, options?: RawAxiosRequestConfig) {
        return TemplateManagerApiFp(this.configuration).getTemplateById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateManagerApi
     */
    public listTemplates(options?: RawAxiosRequestConfig) {
        return TemplateManagerApiFp(this.configuration).listTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TestRes} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPing: async (param?: TestRes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/test/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (param !== undefined) {
                for (const [key, value] of Object.entries(param)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/p/test/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TestItemListFilter} filter 
         * @param {PageReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntitiesWithPaging: async (filter: TestItemListFilter, req: PageReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('listEntitiesWithPaging', 'filter', filter)
            // verify required parameter 'req' is not null or undefined
            assertParamExists('listEntitiesWithPaging', 'req', req)
            const localVarPath = `/api/public/test/list-with-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (req !== undefined) {
                for (const [key, value] of Object.entries(req)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopEntities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/public/test/list-top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/p/test/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TestEntityDto} testEntityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity: async (testEntityDto: TestEntityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testEntityDto' is not null or undefined
            assertParamExists('updateEntity', 'testEntityDto', testEntityDto)
            const localVarPath = `/api/p/test/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testEntityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TestRes} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPing(param?: TestRes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPing(param, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.adminPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestEntityRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TestItemListFilter} filter 
         * @param {PageReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntitiesWithPaging(filter: TestItemListFilter, req: PageReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoTestItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntitiesWithPaging(filter, req, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.listEntitiesWithPaging']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopEntities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestItemDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopEntities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.listTopEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TestEntityDto} testEntityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntity(testEntityDto: TestEntityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(testEntityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.updateEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         * 
         * @param {TestRes} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPing(param?: TestRes, options?: any): AxiosPromise<TestRes> {
            return localVarFp.adminPing(param, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(options?: any): AxiosPromise<TestEntityRes> {
            return localVarFp.getEntity(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestItemListFilter} filter 
         * @param {PageReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntitiesWithPaging(filter: TestItemListFilter, req: PageReq, options?: any): AxiosPromise<PageDtoTestItemDto> {
            return localVarFp.listEntitiesWithPaging(filter, req, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopEntities(options?: any): AxiosPromise<Array<TestItemDto>> {
            return localVarFp.listTopEntities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<TestRes> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestEntityDto} testEntityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity(testEntityDto: TestEntityDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntity(testEntityDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * 
     * @param {TestRes} [param] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public adminPing(param?: TestRes, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).adminPing(param, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getEntity(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getEntity(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestItemListFilter} filter 
     * @param {PageReq} req 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public listEntitiesWithPaging(filter: TestItemListFilter, req: PageReq, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).listEntitiesWithPaging(filter, req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public listTopEntities(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).listTopEntities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestEntityDto} testEntityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public updateEntity(testEntityDto: TestEntityDto, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).updateEntity(testEntityDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WipTemplateMngApi - axios parameter creator
 * @export
 */
export const WipTemplateMngApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTemplate: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('completeTemplate', 'sessionId', sessionId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/complete`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {WipStepConnectionCreateReq} wipStepConnectionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (sessionId: string, wipStepConnectionCreateReq: WipStepConnectionCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createConnection', 'sessionId', sessionId)
            // verify required parameter 'wipStepConnectionCreateReq' is not null or undefined
            assertParamExists('createConnection', 'wipStepConnectionCreateReq', wipStepConnectionCreateReq)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/steps/connection`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wipStepConnectionCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createStep', 'sessionId', sessionId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/step`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection: async (sessionId: string, connectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteConnection', 'sessionId', sessionId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteConnection', 'connectionId', connectionId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/steps/connection/{connectionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStep: async (sessionId: string, stepId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteStep', 'sessionId', sessionId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('deleteStep', 'stepId', stepId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/step/{stepId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getSession', 'templateId', templateId)
            const localVarPath = `/api/p/template/manager/wip/session/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStep: async (sessionId: string, stepId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getStep', 'sessionId', sessionId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('getStep', 'stepId', stepId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/step/{stepId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteps: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSteps', 'sessionId', sessionId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/steps`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {WipStepUpdateReq} wipStepUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep: async (sessionId: string, stepId: string, wipStepUpdateReq: WipStepUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('updateStep', 'sessionId', sessionId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('updateStep', 'stepId', stepId)
            // verify required parameter 'wipStepUpdateReq' is not null or undefined
            assertParamExists('updateStep', 'wipStepUpdateReq', wipStepUpdateReq)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/step/{stepId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wipStepUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {WipStepUpdatePositionReq} wipStepUpdatePositionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStepLocation: async (sessionId: string, stepId: string, wipStepUpdatePositionReq: WipStepUpdatePositionReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('updateStepLocation', 'sessionId', sessionId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('updateStepLocation', 'stepId', stepId)
            // verify required parameter 'wipStepUpdatePositionReq' is not null or undefined
            assertParamExists('updateStepLocation', 'wipStepUpdatePositionReq', wipStepUpdatePositionReq)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/step/{stepId}/location`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"stepId"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wipStepUpdatePositionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSteps: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('validateSteps', 'sessionId', sessionId)
            const localVarPath = `/api/p/template/manager/wip/{sessionId}/validate`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WipTemplateMngApi - functional programming interface
 * @export
 */
export const WipTemplateMngApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WipTemplateMngApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTemplate(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTemplate(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.completeTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {WipStepConnectionCreateReq} wipStepConnectionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(sessionId: string, wipStepConnectionCreateReq: WipStepConnectionCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(sessionId, wipStepConnectionCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.createConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStep(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WipStepCreateData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStep(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.createStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnection(sessionId: string, connectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnection(sessionId, connectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.deleteConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStep(sessionId: string, stepId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStep(sessionId, stepId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.deleteStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.getSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStep(sessionId: string, stepId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WipStepDetailRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStep(sessionId, stepId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.getStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSteps(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WipStepListRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSteps(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.getSteps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {WipStepUpdateReq} wipStepUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStep(sessionId: string, stepId: string, wipStepUpdateReq: WipStepUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WipStepNodeData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStep(sessionId, stepId, wipStepUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.updateStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {WipStepUpdatePositionReq} wipStepUpdatePositionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStepLocation(sessionId: string, stepId: string, wipStepUpdatePositionReq: WipStepUpdatePositionReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStepLocation(sessionId, stepId, wipStepUpdatePositionReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.updateStepLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateSteps(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WipStepValidationRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateSteps(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WipTemplateMngApi.validateSteps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WipTemplateMngApi - factory interface
 * @export
 */
export const WipTemplateMngApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WipTemplateMngApiFp(configuration)
    return {
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTemplate(sessionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.completeTemplate(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {WipStepConnectionCreateReq} wipStepConnectionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(sessionId: string, wipStepConnectionCreateReq: WipStepConnectionCreateReq, options?: any): AxiosPromise<StringDto> {
            return localVarFp.createConnection(sessionId, wipStepConnectionCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep(sessionId: string, options?: any): AxiosPromise<WipStepCreateData> {
            return localVarFp.createStep(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(sessionId: string, connectionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConnection(sessionId, connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStep(sessionId: string, stepId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStep(sessionId, stepId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(templateId: string, options?: any): AxiosPromise<StringDto> {
            return localVarFp.getSession(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStep(sessionId: string, stepId: string, options?: any): AxiosPromise<WipStepDetailRes> {
            return localVarFp.getStep(sessionId, stepId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteps(sessionId: string, options?: any): AxiosPromise<WipStepListRes> {
            return localVarFp.getSteps(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {WipStepUpdateReq} wipStepUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep(sessionId: string, stepId: string, wipStepUpdateReq: WipStepUpdateReq, options?: any): AxiosPromise<WipStepNodeData> {
            return localVarFp.updateStep(sessionId, stepId, wipStepUpdateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} stepId 
         * @param {WipStepUpdatePositionReq} wipStepUpdatePositionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStepLocation(sessionId: string, stepId: string, wipStepUpdatePositionReq: WipStepUpdatePositionReq, options?: any): AxiosPromise<void> {
            return localVarFp.updateStepLocation(sessionId, stepId, wipStepUpdatePositionReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSteps(sessionId: string, options?: any): AxiosPromise<WipStepValidationRes> {
            return localVarFp.validateSteps(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WipTemplateMngApi - object-oriented interface
 * @export
 * @class WipTemplateMngApi
 * @extends {BaseAPI}
 */
export class WipTemplateMngApi extends BaseAPI {
    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public completeTemplate(sessionId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).completeTemplate(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {WipStepConnectionCreateReq} wipStepConnectionCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public createConnection(sessionId: string, wipStepConnectionCreateReq: WipStepConnectionCreateReq, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).createConnection(sessionId, wipStepConnectionCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public createStep(sessionId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).createStep(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public deleteConnection(sessionId: string, connectionId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).deleteConnection(sessionId, connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} stepId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public deleteStep(sessionId: string, stepId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).deleteStep(sessionId, stepId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public getSession(templateId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).getSession(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} stepId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public getStep(sessionId: string, stepId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).getStep(sessionId, stepId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public getSteps(sessionId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).getSteps(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} stepId 
     * @param {WipStepUpdateReq} wipStepUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public updateStep(sessionId: string, stepId: string, wipStepUpdateReq: WipStepUpdateReq, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).updateStep(sessionId, stepId, wipStepUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} stepId 
     * @param {WipStepUpdatePositionReq} wipStepUpdatePositionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public updateStepLocation(sessionId: string, stepId: string, wipStepUpdatePositionReq: WipStepUpdatePositionReq, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).updateStepLocation(sessionId, stepId, wipStepUpdatePositionReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WipTemplateMngApi
     */
    public validateSteps(sessionId: string, options?: RawAxiosRequestConfig) {
        return WipTemplateMngApiFp(this.configuration).validateSteps(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



