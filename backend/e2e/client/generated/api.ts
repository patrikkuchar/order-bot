/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * OpenAPI documentation for My API
 *
 * The version of the OpenAPI document: 59acdd34ea678de65cbe0a25f66df8cefdf5050b
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ConfigurationRes
 */
export interface ConfigurationRes {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationRes
     */
    'appVersion': string;
    /**
     * 
     * @type {number}
     * @memberof ConfigurationRes
     */
    'reloadIntervalMs': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigurationRes
     */
    'enabledDomains': Array<ConfigurationResEnabledDomainsEnum>;
}

export const ConfigurationResEnabledDomainsEnum = {
    Test: 'TEST'
} as const;

export type ConfigurationResEnabledDomainsEnum = typeof ConfigurationResEnabledDomainsEnum[keyof typeof ConfigurationResEnabledDomainsEnum];

/**
 * 
 * @export
 * @interface DecimalRange
 */
export interface DecimalRange {
    /**
     * 
     * @type {number}
     * @memberof DecimalRange
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof DecimalRange
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface LoginReq
 */
export interface LoginReq {
    /**
     * 
     * @type {string}
     * @memberof LoginReq
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginReq
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginRes
 */
export interface LoginRes {
    /**
     * 
     * @type {string}
     * @memberof LoginRes
     */
    'token': string;
    /**
     * 
     * @type {UserInfo}
     * @memberof LoginRes
     */
    'userInfo': UserInfo;
}
/**
 * 
 * @export
 * @interface PageDtoTestItemDto
 */
export interface PageDtoTestItemDto {
    /**
     * 
     * @type {Array<TestItemDto>}
     * @memberof PageDtoTestItemDto
     */
    'content': Array<TestItemDto>;
    /**
     * 
     * @type {PageMetadata}
     * @memberof PageDtoTestItemDto
     */
    'page': PageMetadata;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements': number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PageReq
 */
export interface PageReq {
    /**
     * 
     * @type {number}
     * @memberof PageReq
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageReq
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface RegisterReq
 */
export interface RegisterReq {
    /**
     * Is not valid Email
     * @type {string}
     * @memberof RegisterReq
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface RegisterUniqueEmailReq
 */
export interface RegisterUniqueEmailReq {
    /**
     * 
     * @type {string}
     * @memberof RegisterUniqueEmailReq
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RegisterUniqueEmailRes
 */
export interface RegisterUniqueEmailRes {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterUniqueEmailRes
     */
    'isUnique': boolean;
}
/**
 * 
 * @export
 * @interface TestEntityDto
 */
export interface TestEntityDto {
    /**
     * 
     * @type {string}
     * @memberof TestEntityDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TestEntityDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestEntityDto
     */
    'category': TestEntityDtoCategoryEnum;
    /**
     * 
     * @type {TestEntityLogisticProp}
     * @memberof TestEntityDto
     */
    'logisticProp': TestEntityLogisticProp;
    /**
     * 
     * @type {boolean}
     * @memberof TestEntityDto
     */
    'available': boolean;
    /**
     * 
     * @type {Set<TestEntityProperty>}
     * @memberof TestEntityDto
     */
    'borrows': Set<TestEntityProperty>;
}

export const TestEntityDtoCategoryEnum = {
    Book: 'BOOK',
    Electronics: 'ELECTRONICS',
    Clothing: 'CLOTHING',
    Toy: 'TOY'
} as const;

export type TestEntityDtoCategoryEnum = typeof TestEntityDtoCategoryEnum[keyof typeof TestEntityDtoCategoryEnum];

/**
 * 
 * @export
 * @interface TestEntityLogisticProp
 */
export interface TestEntityLogisticProp {
    /**
     * 
     * @type {number}
     * @memberof TestEntityLogisticProp
     */
    'stockCount': number;
    /**
     * 
     * @type {number}
     * @memberof TestEntityLogisticProp
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface TestEntityProperty
 */
export interface TestEntityProperty {
    /**
     * Is not valid Email
     * @type {string}
     * @memberof TestEntityProperty
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TestEntityProperty
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface TestEntityRes
 */
export interface TestEntityRes {
    /**
     * 
     * @type {TestEntityDto}
     * @memberof TestEntityRes
     */
    'entity'?: TestEntityDto;
}
/**
 * 
 * @export
 * @interface TestItemDto
 */
export interface TestItemDto {
    /**
     * 
     * @type {string}
     * @memberof TestItemDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TestItemDto
     */
    'category': TestItemDtoCategoryEnum;
    /**
     * 
     * @type {number}
     * @memberof TestItemDto
     */
    'price': number;
}

export const TestItemDtoCategoryEnum = {
    Book: 'BOOK',
    Electronics: 'ELECTRONICS',
    Clothing: 'CLOTHING',
    Toy: 'TOY'
} as const;

export type TestItemDtoCategoryEnum = typeof TestItemDtoCategoryEnum[keyof typeof TestItemDtoCategoryEnum];

/**
 * 
 * @export
 * @interface TestItemListFilter
 */
export interface TestItemListFilter {
    /**
     * 
     * @type {string}
     * @memberof TestItemListFilter
     */
    'title'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestItemListFilter
     */
    'categories'?: Array<TestItemListFilterCategoriesEnum>;
    /**
     * 
     * @type {DecimalRange}
     * @memberof TestItemListFilter
     */
    'priceRange'?: DecimalRange;
}

export const TestItemListFilterCategoriesEnum = {
    Book: 'BOOK',
    Electronics: 'ELECTRONICS',
    Clothing: 'CLOTHING',
    Toy: 'TOY'
} as const;

export type TestItemListFilterCategoriesEnum = typeof TestItemListFilterCategoriesEnum[keyof typeof TestItemListFilterCategoriesEnum];

/**
 * 
 * @export
 * @interface TestRes
 */
export interface TestRes {
    /**
     * 
     * @type {string}
     * @memberof TestRes
     */
    'userFullName': string;
    /**
     * 
     * @type {boolean}
     * @memberof TestRes
     */
    'isAdmin': boolean;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'meno'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'priezvisko'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof UserInfo
     */
    'role': UserRole;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserRole = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isEmailUnique: async (registerUniqueEmailReq: RegisterUniqueEmailReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUniqueEmailReq' is not null or undefined
            assertParamExists('isEmailUnique', 'registerUniqueEmailReq', registerUniqueEmailReq)
            const localVarPath = `/api/auth/unique`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUniqueEmailReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginReq} loginReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginReq: LoginReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginReq' is not null or undefined
            assertParamExists('login', 'loginReq', loginReq)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterReq} registerReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerReq: RegisterReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerReq' is not null or undefined
            assertParamExists('register', 'registerReq', registerReq)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isEmailUnique(registerUniqueEmailReq: RegisterUniqueEmailReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUniqueEmailRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isEmailUnique(registerUniqueEmailReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.isEmailUnique']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginReq} loginReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginReq: LoginReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterReq} registerReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerReq: RegisterReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isEmailUnique(registerUniqueEmailReq: RegisterUniqueEmailReq, options?: any): AxiosPromise<RegisterUniqueEmailRes> {
            return localVarFp.isEmailUnique(registerUniqueEmailReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginReq} loginReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginReq: LoginReq, options?: any): AxiosPromise<LoginRes> {
            return localVarFp.login(loginReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterReq} registerReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerReq: RegisterReq, options?: any): AxiosPromise<void> {
            return localVarFp.register(registerReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {RegisterUniqueEmailReq} registerUniqueEmailReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public isEmailUnique(registerUniqueEmailReq: RegisterUniqueEmailReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).isEmailUnique(registerUniqueEmailReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginReq} loginReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginReq: LoginReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterReq} registerReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerReq: RegisterReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/public/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<ConfigurationRes> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getConfig(options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TestRes} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPing: async (param?: TestRes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/test/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (param !== undefined) {
                for (const [key, value] of Object.entries(param)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/p/test/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TestItemListFilter} filter 
         * @param {PageReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntitiesWithPaging: async (filter: TestItemListFilter, req: PageReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('listEntitiesWithPaging', 'filter', filter)
            // verify required parameter 'req' is not null or undefined
            assertParamExists('listEntitiesWithPaging', 'req', req)
            const localVarPath = `/api/public/test/list-with-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (req !== undefined) {
                for (const [key, value] of Object.entries(req)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopEntities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/public/test/list-top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/p/test/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TestEntityDto} testEntityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity: async (testEntityDto: TestEntityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testEntityDto' is not null or undefined
            assertParamExists('updateEntity', 'testEntityDto', testEntityDto)
            const localVarPath = `/api/p/test/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testEntityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TestRes} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPing(param?: TestRes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPing(param, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.adminPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestEntityRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.getEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TestItemListFilter} filter 
         * @param {PageReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntitiesWithPaging(filter: TestItemListFilter, req: PageReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoTestItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntitiesWithPaging(filter, req, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.listEntitiesWithPaging']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopEntities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestItemDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopEntities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.listTopEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TestEntityDto} testEntityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntity(testEntityDto: TestEntityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(testEntityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.updateEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         * 
         * @param {TestRes} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPing(param?: TestRes, options?: any): AxiosPromise<TestRes> {
            return localVarFp.adminPing(param, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(options?: any): AxiosPromise<TestEntityRes> {
            return localVarFp.getEntity(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestItemListFilter} filter 
         * @param {PageReq} req 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntitiesWithPaging(filter: TestItemListFilter, req: PageReq, options?: any): AxiosPromise<PageDtoTestItemDto> {
            return localVarFp.listEntitiesWithPaging(filter, req, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopEntities(options?: any): AxiosPromise<Array<TestItemDto>> {
            return localVarFp.listTopEntities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<TestRes> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestEntityDto} testEntityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity(testEntityDto: TestEntityDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntity(testEntityDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * 
     * @param {TestRes} [param] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public adminPing(param?: TestRes, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).adminPing(param, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getEntity(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).getEntity(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestItemListFilter} filter 
     * @param {PageReq} req 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public listEntitiesWithPaging(filter: TestItemListFilter, req: PageReq, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).listEntitiesWithPaging(filter, req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public listTopEntities(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).listTopEntities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestEntityDto} testEntityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public updateEntity(testEntityDto: TestEntityDto, options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).updateEntity(testEntityDto, options).then((request) => request(this.axios, this.basePath));
    }
}



